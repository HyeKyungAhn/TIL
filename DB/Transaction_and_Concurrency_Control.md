# 트랜잭션

## 1. 트랜잭션이란?
여러개의 쿼리를 하나의 단위로 묶은 것을 말한다.

MySQL에서는 2가지 종류의 테이블을 제공한다.
- myISAM : 트랜잭션 사용할 수 없는 단순한 구조의 테이블
- InnoDB : 다른 DMBS와 동일하게 트랜잭션을 사용할 수 있는 테이블
## 2. 트랜잭션의 4가지 특성(ACID)
### Atomicity
트랜잭션은 일련의 데이터를 처리할 때 모두 성공 또는 실패의 결과를 보장하는 구조이다.

### Consistency
트랜잭션은 데이터베이스 오브젝트에 정합성을 위한 제약 조건을 설정해서 데이터 조작 전 후에 일관성을 보장한다.

### Isolation
사용자들이 동시에 일련의 데이터에 접근했을 때, 각각의 작업이 모순없이 처리됨을 보장하는 트랜잭션의 특성.

사용자들이 아이유의 콘서트를 티켓팅하는 상황을 가정해보자. 한 좌석이 남아있는데 1000명이 동시에 예매를 시도했다.
이때 예약 프로그램은 select를 통해 남은 좌석 수를 사용자에게 제공했을것이고, 사용자가 예매한 후 update를 통해 남은 좌석 수를 갱신해야한다
정상적이라면 먼저 처리된 1명만이 좌석 티켓팅에 성공하고 남은 999명의 사람들은 좌석이 없다는 창을 마주해야한다.
하지만 남은 좌석 데이터에 1000명이 다 접근할 수 있다면 어떻게 될까? 모두가 select를 해서 1자리가 남아있다는 사실을 알고 모두가 동시에 update를 할 수 있는 상황이라면? 1000명이 예매를 했지만 표는 1표만 팔린 이상한 상황이 된다. 좌석이 실제로는 모자라게 된다.

이를 방지하기 위해 데이터베이스는 실행중인 데이터에 lock을 걸어 각각의 데이터 처리에 모순이 발생하지 않지 않게 할 수 있다.
먼저 처리된 1명이 update를 하는 동안 락을 걸어 나머지 999명은 해당 데이터를 수정 못하게 하는 것이다. 1명이 일련의 작업을 다 마친 후 commit까지 하면, 락이 해제되어 나머지 999명은 그 후 남은 좌석 수 데이터에 접근하여 남은 좌석수가 0이라 더이상 예매할 수 없다는 것을 발견할 수 있다.
lock은 보통 테이블, 블럭, 행에 적용할 수 있는데 행에 주로 lock을 건다.
데이터를 단순히 참조만 하는 경우라면 데이터에 lock을 걸 필요가 없다. 

#### 💡 모순이 없다는 말의 의미는 무엇인가?

병렬로 수행하는 작업(=복수의 트랜잭션)이 순서대로 처리된 것과 같은 결과일 때 모순이 없다고 한다.
모순이 없는 결과, 순서대로 처리하는 기능을 데이터베이스에서 제공하는데 이를 직렬화라고 함. 하지만 많은 사용자가 동시에 데이터베이스를 이용하는 상황에서는 비효율적. 그래서 이 직렬화 기능을 완화하여 자신이 아닌 다른 트랜잭션이 관여할 수 있도록 허용하는 정도를 달리해 4가지의 격리수준(Transaction Isolation Level 4)을 만들었다.

1. 커밋되지 않은 읽기(Read Uncommited)
2. 커밋된 읽기(Read Commited)
3. 반복읽기(Repeatable Read)
4. 직렬화 기능(Serializable)

#### 💡 직렬화에는 나타나지 않는 현상들
Dirty Read : 사용자 A가 update하고 commit하지 않았는데, 사용자 B가 읽을 수 있음

Fuzzy(NonRepeatable) Read : 
1. 사용자 A가 첫번째 검색을 함. 1행의 데이터가 'you'임을 확인
2. A가 두 번째 동일한 검색을 하기 직전, 사용자 B가 1행의 데이터를 'they'로 변경 후 commit
3. 사용자 A가 두 번쨰 검색을 함. 1행의 데이터가 'they'로 바뀐 것을 확인
    
    사용자 A는 총 두 번의 검색을 할 때 1행의 데이터가 각각 달랐음. 이를 SELECT가 항상 동일한 결과를 보장하지 못하고 애매하다고 해서 붙여진 이름. 반복이 불가능하다고 해서 NonRepeatable이라고도 함

Phantom Read : 
1. 사용자 A가 첫번째 검색을 함. 총 5행의 결과를 얻음
2. A 가 두 번째 동일한 검색을 하기 직전, 사용자 B가 1행 새로운 행을 insert하고 commit을 함
3. 사용자 A가 두 번쨰 검색을 함. 총 6행의 결과를 얻음

    사용자 A는 총 두 번의 검색을 할 때 데이터의 행 수가 달랐음. 데이터를 조회할 때 데이터가 사라질 수도, 새로 나타날 수도 있어서 Phantom Read라고 이름을 붙임.

|격리수준|Dirty Read|Fuzzy Read|Phantom Read|
|-----|:---:|:---:|:---:|
|Read Uncommited|O|O|O|
|Read Commited|X|O|O|
|Repeatable Read|X|X|O|
|직렬화|X|X|X|

### 지속성(Durability)
트랜잭션을 완료(commit)한 후 그 결과는 영원히 반영되어야한다. 트랜잭션을 완료할(commit)때마다 트랜잭션의 조작정보를 하드디스크의 로그에 저장하여 문제 발생(DB, OS문제 등) 시 로그에서 데이터를 가져와 문제 발생 이전 상태로 복원함으로 지속성을 유지한다.

</br>
</br>

## 3. MVCC에 따른 MySQL의 특성

MVCC(Multi Versioning Concurrency Control)라는 기술 때문에 MySQL이 가지게 된 특성들 
1. 읽기는 갱신중에도 블록되지 않는다.
2. 격리 수준에 따라 select된 데이터가 다를 수 있다.
3. 갱신시 배타적 잠금을 얻는다. 기본적으로 행단위로 얻어 트랜잭션을 종료할 때까지 유지됨. (격리 수준이나 InnoDB의 설정에 따라 잠금하는 행의 범위가 다를 수 있음)
4. 동시에 두 명이상의 사용자가 갱신하는 경우, 나중에 온 트랜잭션이 잠금을 얻으려고 할 때 블록된다. 일정시간을 지나도 잠금을 획득하지 못하는 경우, 'Lock Timeout'이 된다.
5. 갱신할 때(마다) 갱신 전의 데이터를 UNDO로그로 '롤백 세그먼트'라는 영역에 저장.(UNDO 로그의 2가지 용도: 롤백 시 사용, 복수의 트랜잭션이 같은 행을 참조할 때 격리 수준에 대응하는 갱신된 데이터를 보여줄 때 사용)

## 4. 실습
### 상황 
commit하지 않았는데, A 커넥션에서 update한 내용을 B 커넥션에서 select할 수 있다.

### 원인 
1. MySQL이나 Oracle 에서는 DDL 작성시 암묵적인 커밋이 발생한다.
2. 오토커밋
    
    트랜잭션을 구분하는 2가지 모드
    
    a. 하나의 SQL문이 하나의 트랜잭션(오토커밋)
    
    b. 사용자가 Commit, Rollback을 하기 전까지의 쿼리의 묶음이 하나의 트랜잭션
        
    DMBS마다 기본 트랜잭션 모드가 다름. (MySQL, PostgreSQL, SQL Server 등은 오토커밋)

## 타임아웃이란?
한 트랜잭션이 잠금을 획득한 상황에서 다른 트랜잭션이 같은 행에 접근했을 때, 잠금이 풀리기를 기다리다 설정된 시간이 지났을 때 타임아웃됐다고 함.

- 어느정도 기다릴지 설정 가능(최소 1부터 설정 가능)
    
    mysql> set innodb_lock_wait_timeout = 1;
- 타임아웃 됐을 때 롤백되는 단위가 다를 수 있다(Tx 전체 롤백, 문제발생 쿼리만 롤백). MySQL에서는 잠금대기 타임아웃이 되면 문제가 발생한 쿼리만 롤백된다. 이 또한 설정가능하다.
## 교착상태란?
Tx A, Tx B가 각각 a, b 테이블의 1행에 대해 잠금을 획득했다고 하자. 그런데, TX A가 b테이블의 1행에 그리고 TX B가 a테이블의 1행에 접근하여 갱신하는 쿼리를 작성했다. 이 경우 Tx A, TX B는 아무리 기다려도 잠금을 획득할 수 없다. 이를 교착상태라고 한다.
마치 두 사람이 각각 양손에 커피를 들고 서로에게 한 잔의 커피를 주려는 상황과 같음. 둘은 남는 손이 없어서 커피를 내려놓지 않는 이상 커피를 줄 수 없겠죠?

### 교착상태를 피하기 위해서는?
#### DBMS의 전반적 대책
1. 트랜잭션을 자주 커밋한다.
2. 정해진 순서로 테이블(행)에 접근하게 한다. 위의 교착상태의 예에서 Tx A와 Tx B 둘 다 a -> b 순서로 테이블에 접근하면 교착상태에 빠지지 않는다.
3. 필요없는 경우 읽기 잠금획득(select .. for update)을 사용하지 않는다.
4. 쿼리에 의한 잠금 범위를 더 좁히거나 잠금정도를 더 작은 것으로 한다.
5. 한 테이블에서 동시에 많은 연결로부터의 갱신으로 교착상태가 자주 발생한다면 단위 잠금을 획득해 갱신을 직렬화하면 동시성은 떨어지나 교착상태가 발생하지 않아 효율 증가될 수 있음

#### MySQL의 대책
1. 테이블에 적절한 인덱스를 추가해 쿼리가 이를 이용하게 한다. 인덱스가 사용되지 않는 경우에는 필요한 행의 잠금이 아닌 스캔한 행 ㅈ전체에 대해 잠금이 걸림.

## 해서는 안되는 트랜잭션 처리
- 오토커밋(커밋 부하가 너무 높다)
- 긴 트랜잭션
    - 대량 처리를 한 트랜잭션에서 수행
        - 트랜잭션 처리를 위해 갱신한 테이블이나 행을 잠궈야하고 잠금간의 교차가 일어날 경우 이 긴 트랜잭션이 롤백 될 수 있으며, 이 긴 트랜잭션의 롤백을 위한 undo로그를 트랜잭션 종료까지 가지고 있어야하는데, 용량이 만만치 않음
    - 아무것도 하지 않는 트랜잭션을 열어두기 
        - 반복 읽기 유지를 위해 UNDO로그 유지해야함.
    - 트랜잭션 중에 대화 처리 넣기
        - 사용자의 대화를 처리를 기다려야함 시스템의 효율 저하
    - 처리 능력 이상의 트랜잭션 수
        - 상한설정

## 그 외
DDL(Definition, 스키마/테이블), DML(Manipulation, 테이블), DCL(Control, commit/rollback)


## Todo & Q

- Fuzzy, Phantom Read가 비슷한 것 같은데 차이는?

- select for update?

- 반복읽기와 직렬화의 차이는?

- MVCC 좀더 알아보기

- UNDO 로그가 필요없어서 해제되어 메모리 영역을 재사용할 수 있을 때, 왜 OS 파일 시스템에서의 크기는 줄어들지 않는지?
- 인덱스란?
- 잠금 정도와 교착상태의 연관성?

## 참조
데이터베이스 첫걸음 - 미크, 기무라 메이지(한빛미디어)