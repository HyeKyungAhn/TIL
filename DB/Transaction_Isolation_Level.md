# 트랜잭션 격리 수준과 MVCC

## 4 levels of Isolation

### Read Committed
"쿼리를 실행한 시점"에 커밋된 데이터를 읽어들입니다. 동일한 쿼리를 반복해서 실행할 때 쿼리 사이에 다른 트랜잭션이 커밋을 했다면 쿼리문 실행 시 그 결과가 반영됩니다.(=dirty read를 허용)

트랜잭션이 종료되기까지 갱신한 행에대한 (read 또는 wirte)lock을 유지하여 다른 트랜잭션으로부터의 commit되지 않은 데이터의 조회와 갱신을 막습니다.

### Repeatable Read
Repeatable Read는 "트랜잭션을 시작한 시점"에 커밋된 데이터를 읽어들입니다. 이후 해당 데이터에 대해 동일한 쿼리를 반복해서 실행하면 동일한 데이터를 읽습니다(=repeatable read). 쿼리 사이에 해당 데이터에 대해 다른 트랜잭션이 커밋을 하더라도 반영되지 않습니다.

### Serializable
시스템 전체에 트랜잭션이 1개만 있는 것처럼 동작함. 모든 트랜잭션은 반드시 순서대로 실행되어야하기 때문에 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근 못함.

### Read UnCommitted
현재 Oracle, PostgreSQL, Firebird에서 지원 x, MySQL에서도 커밋되지 않은 읽기를 이용할 필요 x
Read UnCommitted가 있는 이유. 예전에는 트랜잭션의 고립성을 위해 읽기를 블록하는 경우가 있었다. 이 때 Read UnCommitted를 사용하면 순간의 대략적인 데이터를 쉽게 얻을 수 있었음. 현재는 MVCC를 사용하여 읽기가 블락되지 않기 때문에 이용할 필요가 없는 것.

## MVCC
MVCC은 Multiversion concurrency control(다중 버전 병행수행 제어)의 약어로, 데이터베이스에서 동시성 제어를 위해 사용되는 방법론. 데이터의 여러 버전을 생성하여 격리수준이 다른 트랜잭션들의 동시 접근에 대처한다.

MVCC의 핵심 전략은 일련번호, 타임스탬프(=Transaction ID)를 데이터에 할당하여 데이터버전을 관리하는 것이다. 트랜잭션의 시작 시점(Start transaction문 실행)에서 트랜잭션 ID를 InnoDB 스토리지 엔진에서 자동생성하여 할당함. MVCC 데이터 버전은 각각 고유한 트랜잭션 ID를 저장하고 있는데, 이 ID는 데이터를 갱신하여 데이터버전을 생성한 트랜잭션의 ID이다. 데이터 버전의 트랜잭션 ID는 버전이 생성된 시점에 결정되어 이후 수정되지 않는다.

읽기 작업에서는 현재 진행중인 트랜잭션의 ID보다 작은 트랜잭션 ID를 가진 버전만 읽을 수 있어 다른 Tx에서 데이터를 갱신하더라도 영향받지 않고 일관적으로 데이터를 읽을 수 있다. 쓰기 작업에서는 갱신시 새로운 ID를 할당하고 해당 트랜잭션 ID를 가진 버전에서만 변경이 가능.(다른 Tx에서 데이터를 갱신한다면 변경이 아닌 새로운 버전 생성) 이러한 방법으로 MVCC는 데이터베이스의 동시성을 보장해준다.

### 이전버전의 데이터는 어디에 저장할까?
트랜잭션 시작 시 undo 로그가 생성되는데, 이 UNDO 로그에는 트랜잭션이 데이터를 변경할 때마다 변경 전의 내용이 저장된다. 

## 3. MVCC에 따른 MySQL의 특성

MVCC(Multi Versioning Concurrency Control)라는 기술 때문에 MySQL이 가지게 된 특성들 
1. 읽기는 갱신중에도 블록되지 않는다.
2. 격리 수준에 따라 select된 데이터가 다를 수 있다.
3. 갱신시 배타적 잠금을 얻는다. 기본적으로 행단위로 얻어 트랜잭션을 종료할 때까지 유지됨. (격리 수준이나 InnoDB의 설정에 따라 잠금하는 행의 범위가 다를 수 있음)
4. 동시에 두 명이상의 사용자가 갱신하는 경우, 나중에 온 트랜잭션이 잠금을 얻으려고 할 때 블록된다. 일정시간을 지나도 잠금을 획득하지 못하는 경우, 'Lock Timeout'이 된다.
5. 갱신할 때(마다) 갱신 전의 데이터를 UNDO로그로 '롤백 세그먼트'라는 영역에 저장.(UNDO 로그의 2가지 용도: 롤백 시 사용, 복수의 트랜잭션이 같은 행을 참조할 때 격리 수준에 대응하는 갱신된 데이터를 보여줄 때 사용)
-> repeatable read, read committed에서 (갱신되었지만 commit되지 않은)데이터를 조회할 때 UNDO로그를 읽는 것이다.
