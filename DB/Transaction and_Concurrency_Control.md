# 트랜잭션

## 1. 트랜잭션이란?
여러개의 쿼리를 하나의 단위로 묶은 것을 말한다.

MySQL에서는 2가지 종류의 테이블을 제공한다.
- myISAM : 트랜잭션 사용할 수 없는 단순한 구조의 테이블
- InnoDB : 다른 DMBS와 동일하게 트랜잭션을 사용할 수 있는 테이블
## 2. 트랜잭션의 4가지 특성(ACID)
### Atomicity
트랜잭션은 일련의 데이터를 처리할 때 모두 성공 또는 실패의 결과를 보장하는 구조이다.

### Consistency
트랜잭션은 데이터베이스 오브젝트에 정합성을 위한 제약 조건을 설정해서 데이터 조작 전 후에 일관성을 보장한다.

### Isolation
사용자들이 동시에 일련의 데이터에 접근했을 때, 각각의 작업이 모순없이 처리됨을 보장하는 트랜잭션의 특성.

사용자들이 아이유의 콘서트를 티켓팅하는 상황을 가정해보자. 한 좌석이 남아있는데 1000명이 동시에 예매를 시도했다.
이때 예약 프로그램은 select를 통해 남은 좌석 수를 사용자에게 제공했을것이고, 사용자가 예매한 후 update를 통해 남은 좌석 수를 갱신해야한다
정상적이라면 먼저 처리된 1명만이 좌석 티켓팅에 성공하고 남은 999명의 사람들은 좌석이 없다는 창을 마주해야한다.
하지만 남은 좌석 데이터에 1000명이 다 접근할 수 있다면 어떻게 될까? 모두가 select를 해서 1자리가 남아있다는 사실을 알고 모두가 동시에 update를 할 수 있는 상황이라면? 1000명이 예매를 했지만 표는 1표만 팔린 이상한 상황이 된다. 좌석이 실제로는 모자라게 된다.

이를 방지하기 위해 데이터베이스는 실행중인 데이터에 lock을 걸어 각각의 데이터 처리에 모순이 발생하지 않지 않게 할 수 있다.
먼저 처리된 1명이 update를 하는 동안 락을 걸어 나머지 999명은 해당 데이터를 수정 못하게 하는 것이다. 1명이 일련의 작업을 다 마친 후 commit까지 하면, 락이 해제되어 나머지 999명은 그 후 남은 좌석 수 데이터에 접근하여 남은 좌석수가 0이라 더이상 예매할 수 없다는 것을 발견할 수 있다.
lock은 보통 테이블, 블럭, 행에 적용할 수 있는데 행에 주로 lock을 건다.
데이터를 단순히 참조만 하는 경우라면 데이터에 lock을 걸 필요가 없다. 

#### 💡 모순이 없다는 말의 의미는 무엇인가?

병렬로 수행하는 작업(=복수의 트랜잭션)이 순서대로 처리된 것과 같은 결과일 때 모순이 없다고 한다.
모순이 없는 결과, 순서대로 처리하는 기능을 데이터베이스에서 제공하는데 이를 직렬화라고 합니다. 하지만 많은 사용자가 동시에 데이터베이스를 이용하는 상황에서는 비효율적입니다. 그래서 이 직렬화 기능을 완화하여 자신이 아닌 다른 트랜잭션이 관여할 수 있도록 허용하는 정도를 달리해 4가지의 격리수준(Transaction Isolation Level 4)을 만들었다.

1. 커밋되지 않은 읽기(Read Uncommited)
2. 커밋된 읽기(Read Commited)
3. 반복읽기(Repeatable Read) 이게 뭐지?
4. 직렬화 기능(Serializable)

#### 💡 직렬화에는 나타나지 않는 현상들
Dirty Read : 사용자 A가 update하고 commit하지 않았는데, 사용자 B가 읽을 수 있음

Fuzzy(NonRepeatable) Read : 
1. 사용자 A가 첫번째 검색을 함. 1행의 데이터가 'you'임을 확인
2. A가 두 번째 동일한 검색을 하기 직전, 사용자 B가 1행의 데이터를 'they'로 변경 후 commit
3. 사용자 A가 두 번쨰 검색을 함. 1행의 데이터가 'they'로 바뀐 것을 확인
    
    사용자 A는 총 두 번의 검색을 할 때 1행의 데이터가 각각 달랐음. 이를 SELECT가 항상 동일한 결과를 보장하지 못하고 애매하다고 해서 붙여진 이름. 반복이 불가능하다고 해서 NonRepeatable이라고도 함

Phantom Read : 
1. 사용자 A가 첫번째 검색을 함. 총 5행의 결과를 얻음
2. A 가 두 번째 동일한 검색을 하기 직전, 사용자 B가 1행 새로운 행을 insert하고 commit을 함
3. 사용자 A가 두 번쨰 검색을 함. 총 6행의 결과를 얻음

    사용자 A는 총 두 번의 검색을 할 때 데이터의 행 수가 달랐음. 데이터를 조회할 때 데이터가 사라질 수도, 새로 나타날 수도 있어서 Phantom Read라고 이름을 붙임.

|격리수준|Dirty Read|Fuzzy Read|Phantom Read|
|-----|:---:|:---:|:---:|
|Read Uncommited|O|O|O|
|Read Commited|O|O|O|
|Repeatable Read|O|O|O|
|직렬화|O|O|O|

</br>
</br>


## 3. 실습
### 상황 
commit하지 않았는데, A 커넥션에서 update한 내용을 B 커넥션에서 select할 수 있다.

### 원인 
1. MySQL이나 Oracle 에서는 DDL 작성시 암묵적인 커밋이 발생한다.
2. 오토커밋
    
    트랜잭션을 구분하는 2가지 모드
    
    a. 하나의 SQL문이 하나의 트랜잭션(오토커밋)
    
    b. 사용자가 Commit, Rollback을 하기 전까지의 쿼리의 묶음이 하나의 트랜잭션
        
    DMBS마다 기본 트랜잭션 모드가 다름. (MySQL, PostgreSQL, SQL Server 등은 오토커밋)

## 그 외
DDL(Definition, 스키마/테이블), DML(Manipulation, 테이블), DCL(Control, commit/rollback)


## 질문

Fuzzy, Phantom Read가 비슷한 것 같은데 차이는?
select for update?
MVCC? -> 책에서 이후에 다룸
