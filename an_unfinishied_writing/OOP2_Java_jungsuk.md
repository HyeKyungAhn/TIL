# 객체지향적 프로그래밍

## 상속
### 상속이란?
기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것

### 사용
```
class Child extends Parent{}
```
### 상속의 특징
- 조상, 자손 클래스
- 자손 클래스는 조상의 모든 멤버(생성자, 초기화 블록 제외)를 상속받음
- 조상 클래스가 변경되면 자손이 영향을 받음
- 자손 클래스의 멤버는 조상보다 같거나 많다
- 클래스간의 관계에서 형제 관계는 없다. 상속 관계만 있을 뿐.
- 자손 클래스의 인스턴스 생성 시, 조상과 자손의 멤버가 합쳐진 하나의 인스턴스로 생성됨

### 상속의 장점
- 클래스를 재사용하기 떄문에 작성해야하는 코드의 수가 줄어든다
- 중복 코드가 줄어든다
    - 같은 내용의 코드를 하나 이상의 코드에 중복 추가해야하는 경우, 상속으로 중복 제거
- 기존 클래스를 변경하면 새로운 클래스도 변경되기 때문에 추가 및 변경에 용이하다(유지보수, 생산성)
    - 하지만 기존 클래스의 변수와 메서드는 이를 상속받는 모든 클래스에서도 사용되기 떄문에 매우 잘 작성해야함
<details>
<summary>상속과 메서드의 차이</summary>
<div markdown = 1>

상속과 메서드의 작성의 의도를 헷갈릴 때가 있다. 큰 규모의 프로젝트를 안해봐서 그런듯.

### 메서드

- 메서드는 반복되는 코드를 하나로 묶어 다루는 것이다. 마치 블랙박스처럼 안에가 어떻게 구현되어있는지를 몰라도 이 메서드의 기능과 입력해야하는 입력값만 넣으면 원하는 결과값을 받아볼 수 있다.
- 메서드 작성을 통해 구조화된 코드를 작성할 수 있다
- 또 중복 코드를 제거할 수 있다. 같은 코드를 다른 곳에 똑같이 작성하는 대신, 메서드를 호출하기만 하면 된다.
- 메서드는 재사용성이 높다. 다른 말로 하면, 여러번 사용될 것같은 코드만 메서드로 작성한다는 의미이다. 내가 작성한 메서드를 API로 만들어 놓으면 다른 누군가가 다른 프로젝트에서도 사용할 수 있다
### 상속
- 상속은 클래스의 재사용이다
- 메서드와 달리 상속은 기존 코드와 재사용하는 코드 간에 상속'관계'가 생긴다
- 클래스는 '확장'된다
    - 뼈에 계속 살을 덧붙이는 식으로 확장된다.
- 조상의 변화가 자손에게 영향을 주지만, 그 반대로는 하지 못한다. 마치 유산과도 같은것..
- 단순히 코드의 중복을 방지하기 위해 상속을 해서는 안된다. 확장될 가능성이 있는 클래스인지, 확장 될거라면 무엇이 공통된 코드가 되어야하는지를 고려해서 상속해야한다.
</details>

### 포함관계
- 한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 것

### 포함관계, 상속관계 결정하기
- is/has

### 단일 상속
- 자바에서는 오직 단일 상속만 허용
- 다중 상속 시 시그니쳐가 같은 메서드를 구분할 수 없어 충돌 발생
- 다중 상속을 구현해야할 경우, 비중이 높은 클래스 1개를 상속, 나머지는 포함관계로(인터페이스를 활용하면 다형성 활용 가능)

### Object 클래스 - 모든 클래스의 조상
- 모든 클래스 상속 계층도의 최상위의 조상 클래스
- 다른 클래스의 상속을 받지 않는 클래스는 Object를 상속(컴파일러가 붙여줌)

## 오버라이딩
### 오버라이딩이란
- 상속받은 메서드의 내용을 재작성하는 것
- 자손 클래스 자신에 맞게 변경해야하는 경우에 오버라이딩

### 오버라이딩 조건
- 이름 동일
- 매개변수의 갯수, 타입 동일
- 반환타입 동일(JDK1.5~ 자손클래스 타입으로 변경 가능)
- 접근 제어자는 같거나 넓은 범위로 변경 가능
- 더 많은 수의 예외를 선언할 수 었다(갯수가 아닌 범위)
- 인스턴스 메서드를 static으로, 또는 그 반대로 변경 불가
- static 메서드 오버라이딩 가능하나 불가. 오버라이딩이 아닌 클래스의 새로운 static 메서드를 작성하는 것(그래서 클래스이름.메서드이름 으로 접근함)

### 오버라이딩 vs 오버로딩
- 오버로딩: 기존에 없던 메서드를 새로 작성
- 오버라이딩: 상속받은 메서드의 내용을 변경

### super
- 자손클래스에서 조상클래스로부터 상속받은 멤버를 가리킬 때 사용하는 참조변수
- 자손에서 오버라이딩 했을 떄 구별을 위해 사용
- 모든 인스턴스 멤버에는 자신이 속한 인스턴스의 주소가 지역변수로 저장(this, super)
- 조상 클래스의 메서드에 내용을 '추가'(완전 새로 작성x)하는 경우에 super를 사용하여 조상클래스의 메서드를 포함하는 것이 좋다.(조상의 변경이 자동 반영되니까)

### super() - 조상클래스의 생성자
- 조상 클래스의 생성자를 호출하는데 사용
- 초기화 작업이 목적
- Object 클래스를 제외한 모든 클래스의 생성자 첫 줄에 생성자 this() 또는 super()가 호출되어야한다. 그렇지 않으면 컴파일러가 super()를 생성자의 첫줄에 삽입
    - 자손 클래스의 멤버에서 조상의 멤버를 사용할 수도 있기에 먼저 초기화되어야한다
- 조상클래스의 멤버는 조상클래스의 생성자로 초기화되어야한다

## package와 import
### 패키지
- 관련있는 클래스들의 묶음
- 클래스의 실제 이름은 패키지를 포함한 것
- 클래스가 물리적으로 하나의 클래스 파일, 패키지는 물리적으로 하나의 디렉터리
- 하나의 소스파일에는 첫 문장으로 단 한 번의 패키지 선언만 가능
- 모든 클래스는 반드시 하나의 패키지에 속해야
- 패키지는 점(.)을 구분자로 계층구조로 구성 가능

### 패키지의 선언
```package 패키지명;```

### import문
- 소스파일에서 사용된 클래스 이름에서 패키지 이름을 생략하기 위해 사용
- 컴파일러에 import문의 패키지에 대한 정보를 제공하는 것

### import문의 선언
```
1. package문
2. import문
3. 클래스 선언
```
- *의 사용
    - 패키지에 속하는 모든 클래스를 패키지 명 없이 사용할 수 있다
    - 컴파일러가 해당 패키지에서 일치하는 클래스 명을 찾지 않아도 된다
    - 실행 시 성능상의 차이가 없다
    - 하위 패키지의 클래스까지 포함하는 것은 아님
- java.lang 패키지의 import문은 생략되어있어 작성하지 않아도 사용할 수 있다

### static import문
- static 멤버를 호출할 떄 클래스 이름 생략 가능

## 제어자
- 선언부에 사용되어 부가적 의미 부여

### static - 클래스의, 공통적인
- 인스턴스 생성하지 않고 사용가능
- 클래스 변수
    - 모든 인스턴스가 공유하는 변수
    - 클래스가 메모리에 로드될 때 생성
- 메서드
    - 메서드 내에서 인스턴스 멤버를 사용하지 않는 메서드
    - 확장되지 않는 메서드
- static이 사용될 수 있는 곳
    - 멤버변수, 메서드, 초기화 블럭

### final - 마지막의, 변경될 수 없는

|종류|특징|
|---|---|
|클래스|변경될 수 없는 클래스, 확장될 수 없음|
|메서드|변경될 수 없는 메서드, 오버라이딩 불가|
|멤버변수, 지역변수|값을 변경할 수 없는 상수|

- 생성자를 이용한 final변수의 초기화
    - 보통 생성과 초기화를 동시에 하지만, 인스턴스 변수는 생성자로 초기화 가능
    - 인스턴스 별로 다른 값을 가진 상수를 선언하기 위한 목적

### abstract - 추상의, 미완성의
- 메서드에 사용
    - 선언부만 작성된 추상 메서드를 선언하는데 사용
- 클래스에 사용
    - 클래스 내에 추상 메서드가 존재함을 쉽게 알 수 있게 하는 목적
    - 인스턴스 생성 불가
    - 반드시 상속 해서 추상메서드를 완성하게 강제한다
    - 추상 메서드가 없고 빈 몸통만 있는 메서드만 있어도(java.awt.event.WindowAdapter) 인스턴스를 생성할 수 없게하고, 상속받아 원하는 메서드만 오버라이딩해서 사용할 수 있게하는 경우 존재.

### 접근 제어자(access modifier)
- 멤버(멤버변수, 메서드, 생성자) 또는 클래스에 사용
- 멤버 또는 클래스를 외부에서 접근하지 못하도록 사용
- 접근 제어자가 지정 안되어있다면, default임

|제어자|같은 클래스|같은 패키지|자손 클래스|전체|
|---|--|--|--|--|
|public|O|O|O|O|
|protected|O|O|O|X|
|(default)|O|O|X|X|
|private|O|X|X|X|

```Public > Protected > default > private```

#### 접근 제어자를 이용한 캡슐화
- 접근제어자 사용 이유는 
    1. 클래스 내부에 선언된 데이터를 보호하기 위함
        - 데이터를 함부로 변경할 수 없도록 접근을 제한
    2. 위부에는 보여줄 필요없는, 내부에서만 사용되는 부분을 감추기 위해서
    3. 코드 수정 시 영향 범위 최소화
- 상속을 확장될 수 있는 클래스는 자손에서 접근이 가능하도록 protected로

#### 생성자의 접근 제어자
- 보통 생성자의 접근제어자는 클래스의 접근 제어자와 같으나, 다르게 작성 가능
- 생성자의 접근 제어자가 private
    - 외부에서 객체 생성 불가(내부에서는 가능)
    - 내부에서 생성한 객체를 반환하는 public static 메서드를 제공 -> 싱글톤 패턴
    - 사용할 수 있는 인스턴스의 개수 제한
    - 생성자가 private인 클래스는 자손 클래스를 가질 수 없다
        - final을 더 추가해서 상속 불가능함을 알리자

### 제어자의 조합
1. 메서드에 static과 abstract를 함께 사용 불가
    - static은 바디가 있는 메서드에만 사용 가능
2. 클래스에 abstract와 final 동시 사용 불가
    - abstract는 상속을 강제하는 제어자인데, final은 상속을 불가하게 하는 제어자로 모순됨
3. abstract 메서드의 제어자가 private일 수 없다
    - 접근 제어자가 private이면, 상속하여 바디를 구현할 수 없기 때문이다
4. 메서드에 private과 final을 같이 사용할 필요가 없다
    - 오버라이딩이 불가함을 알리는 것은 private만으로도 충분하다

## 다형성
### 다형성이란?
1. 여러가지 형태를 가질 수 있는 능력
2. 조상 클래스타입으로 여러 자손 클래스타입의 인스턴스를 참조할 수 있는 성질

### 특징
- 인스턴스를 어떤 타입으로 참조하는지에 따라 사용할 수 있는 멤버의 갯수가 달라짐
- 조상 타입의 참조변수로 자손 타입의 인스턴스를 참조 가능
- 자손타입의 참조변수로 조상타입의 인스턴스를 참조 불가
    - 참조변수가 접근할 수 있는 범위가 인스턴스가 실제 가진 멤버 보다 더 많음, 존재하지 않는 멤버를 사용할 수 도 있다
### 참조변수의 형변환
- 서로 상속관계에 있는 클래스 사이에서만 가능
- 자손 -> 조상 형변환 생략 가능
    - 참조변수가 다룰 수 있는 멤버의 수가 실제 인스턴스 멤버의 수보다 작거나 같아 문제될게 없음
- 자손 <- 조상 형변환 생략 불가
    - 참조변수가 존재하지 않는 멤버를 사용할 가능성이 있어 불가
- 컴파일 시, 참조변수 간 형변환만 체크(실제 인스턴스 체크 x)
    - 형변환 전에 instanceof 연산자 사용해서 실제 인스턴스 타입 확인하기
- 형변환은 실제 인스턴스에 아무런 영향 x, 단지 형변환을 통해 참조변수를 통해 인스턴스에서 사용할 수 있는 멤버의 갯수를 조정하는 것

### instanceof 연산자
- 참조변수가 참조하는 인스턴스의 실제 타입을 확인하는 연산자
- 왼쪽에 참조변수, 오른쪽에 클래스 타입
- true -> 오른쪽 클래스의 타입으로 형변환 가능
    - 실제 인스턴스의 멤버와 클래스 멤버 수가 같거나 인스턴스가 더 많음

### 참조변수와 인스턴스의 연결
- 메서드
    - 오버라이딩한 경우에도 참조변수의 타입과 관계없이 실제 인스턴스에 정의된 메서드 호출
- 참조변수
    - 오버라이딩한 경우, 참조변수의 타입에 따라 달라짐
    - 하지만 중복정의 되지 않았다면 참조변수에 관계없이 동일한 참조변수를 불러온다
- 인스턴스 변수에 직접 접근시, 참조변수의 타입에 따라 사용되는 인스턴스 변수가 달라질 수 있다
    - getter, setter를 통해 간접접근 해야한다

### 매개변수의 다형성
- 매개변수가 A타입의 참조변수라면, 메서드의 매개변수로 A의 자손타입 클래스는 다 인자로 올 수 았다는 의미

### 여러 종류의 객체를 매열로 다루기
- 조상타입의 참조변수 배열 사용하면 공통 조상을 가진 서로 다른 종류의 객체를 배열로 묶어 다룰 수 있다.

참고
- 남궁성의 자바의 정석




