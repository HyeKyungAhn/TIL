# 연산자
## 1. 연산자
<details>
<summary>연산자와 피연산자</summary>
<div markdown = 1>

- 연산자 : 연산을 수행하는 기호
- 피연산자 : 연산의 대상(수식, 리터럴, 변수, 상수)
</div>
</details>

<details>
<summary>식과 연산자의 사용(평가)</summary>
<div markdown = 1>

- 연산자와 피연산자의 조합
- 평가(evaluation)
    - 식을 계산하여 결과를 얻는 것
    - 피연산자의 타입은 결과의 타입과 동일
- 식을 평가하여 '사용'해야한다. 대입연산자를 통해 변수에 대입하거나, System.out.print()로 화면에 출력하는 방법 등이 있다.
</div>
</details>

<details>
<summary>연산자의 분류</summary>
<div markdown = 1>

- 기능
    - 산술, 논리, 비교, 대입, 그 외(형변환, 삼항, instanceof..)
- 피연산자의 개수
    - 단항, 이항, 삼항
</div>
</details>

<details>
<summary>연산자의 우선순위(결합규칙)</summary>
<div markdown = 1>

- 산술 > 비교 > 논리 > 대입
- 단항 > 이항 > 삼항
- 연산자의 결합규칙(우선순위가 같을 때)
    - **단항 연산자**와 **대입 연산자**를 제외한 모든 연산의 진행방향은 **왼쪽 ➝ 오른쪽**
</details>

<details>
<summary>산술변환이란</summary>
<div markdown = 1>

- (이항 연산자의)연산 전에 피연산자 타입을 일치시키기 위해 일어나는 자동형변환
- 규칙
    1. 두 피연산자의 타입을 일치시킨다(보다 큰 타입으로)
        - 값 손실 최소화
    2. 피연산자의 타입이 int보다 작은타입이면 int로 변환(이 특징 잊기 쉬우니 주의하기)
        - 정수형 중 int가 가장 효율적으로 처리되는 기본 타입
</details>

**\*\* 아래의 (거의)모든 연산자에서 연산결과, 피연산자 대상, 우선순위, 산술변환 여부 다룸**

## 단항 연산자
<details>
<summary>증감 연산자(연산 결과, 피연산자 대상, 산술 변환, 분류)</summary>
<div markdown = 1>

- ++, --
- 연산 결과
    - 피연산자에 '저장된 값'을 1 증가 또는 감소시킴
- 피연산자
    - 피연산자로 정수, 실수 가능하나 상수는 불가능(변경이 불가하기 때문)
- 산술변환이 발생하지 않음
- 문자관련 계산에 유리(형변환이 없어서)
- 전위형
    - 값이 참조되기 전에 증가
- 후위형
    - 값이 참조된 후에 증가
</details>

<details>
<summary>부호 연산자(종류만)</summary>
<div markdown = 1>

- '-'
    - 피연산자의 부호를 반대로 변경함
- '+'
    - 하는 일이 없다
</details>

## 산술연산자
<details>
<summary>사칙 연산자<del>(우선순위, 나누기의 특징, 산술변환의 함정 세 가지, 문자간의 사칙연산, 상수 리터럴의 사칙연산, 활용 2가지)</del></summary>
<div markdown = 1>

- 내가 아는 그 사칙 연산자
- 우선순위
    - *, /, % > +, -
- 나누기의 특징
    - 피연산자 타입 == 결과값 타입
        - 실수 결과를 얻으려면, 피연산자 중 하나가 실수 타입이어야
        - int형인 경우, 나누기 결과값에서 소수점 이하 값은 버려짐
    - 나누는 수가 0
        - 피연산자가 정수형(0)인 경우 ➝ ArithmeticException
        - 피연산자가 실수형(0.0, 0.0f)인 경우 ➝ Infinity
- 산술변환의 함정 세가지
    1. 연산 시 int보다 작은 타입은 int로 형변환
        - 결과값이 int형 ➝ 명시적 형변환이 필요
        
            ``` 
            byte a = 10;
            byte b = 20;
            // byte c = a + b; //컴파일 에러 발생
            byte c = (byte)(a + b);
            ```
    2. 1번의 해결방법 적용 시 overflow로 값손실 발생
        - overflow 방지를 위해 미리 큰 자료형 사용하기
        
            ``` 
            byte a = 100;
            byte b = 200;
            // byte c = (byte)(a + b); 
            // 에러 발생 
            // 자료형의 범위를 넘음
            int c = a + b;
            ```
    3. 연산의 결과가 overflow
        - 피연산자를 보다 큰 타입으로 미리 명시적 형변환
            ```
            int a = 1_000_000;
            int b = 2_000_000;
            long c = a * b: //2,000,000,000,000
            // 실제 결과값 : -1454759936
            long d = (long)a * b;
            // 2,000,000,000,000
            ```
    4. 순서를 고려하여 식 작성하기
        - 같은 의미의 식이라도 연산의 순서에 따라 다른 결과가 나올 수 있다
            ```
            int a = 1_000_000;
            
            long b = a * a / a;
            // -727
            long c = a / a * a;
            //1,000,000
            ```
- 문자간의 사칙연산
    - 문자(char)는 유니코드(정수)로 저장됨
    - 정수간의 사칙연산과 동일
    - 'a'==97, 'A'==65, '0'==48 
- 상수 or 리터럴 간의 사칙연산
    - 컴파일러가 미리 덧셈 연산을 수행(=실행 시에 연산 수행x)
    - 그래서 리터럴 연산을 풀어써도 실행 시의 성능에는 차이가 없음
- 사칙연산을 활용 2가지
    - 실수의 소수점 n자리수 이하 버리기
    - 반올림
</details>

<details>
<summary>나머지 연산자(연산 결과, 나누는 수, 음수)</summary>
<div markdown = 1>

- 연산 결과
    - 나머지 값을 결과로 반환
- 나누기와 동일하게 나누는 수로 0은 사용 불가
- 연산자는 나누는 수로 음수도 허용하나, 부호는 무시 됨
</details>

## 비교연산자
<details>
<summary>대소비교 연산자(결과, 종류만)</summary>
<div markdown = 1>

- 연산 결과 
    - 두 피연산자의 값의 크기를 비교
- 종류
    - \>, <, >=, <=
</details>

<details>
<summary>등가비교 연산자<del>(종류, 연산 결과, 연산 대상, 산술 변환, 문자열 비교)</del></summary>
<div markdown = 1>

- ==, !=
- 연산 결과
    - 두 피연산자의 값이 같은지 다른지를 비교
- 연산 대상
    - 모든 자료형에 사용 가능
    - 기본형
        - 변수에 저장된 값이 같은지 확인
        - 객체의 주소값을 비교
- 산술변환
    - 실수타입의 비교
        - 소수점 이하의 값이 0이상인 실수를 2진수로 변환할 때 오차 발생
        - double, float타입의 값을 비교할 때 double을 float으로 형변환한 다음 비교해야
- 문자열 비교
    - 문자열 내용을 비교하기 위해서는 반드시 ==가 아닌 equals()를 사용
</details>

## 논리 연산자
<details>
<summary>논리 연산자<del>(연산 결과, 우선순위, 효율적인 연산)</del></summary>
<div markdown = 1>

- 연산 결과
    - || (OR 결합)
        - 피연산자 중 어느 한 쪽만 true이어도 true
    - && (And 결합)
        - 피연산자 양 쪽 다 true여야 true
- 우선 순위
    - && > ||
- 효율적인 연산
    - || 
        - 좌측 연산자가 true이면 우측 피연산자의 값은 평가 x
    - &&
        - 좌측 연산자가 false이면 우측 피연산자의 값은 평가 x
</details>

<details>
<summary>논리 부정 연산자(연산결과만)</summary>
<div markdown = 1>

- !x
- 연산 결과
    - 피연산자와 반대되는 boolean값
</details>

<details>
<summary>비트 연산자<del>(연산 결과, 논리 연산자 3개와 각각 활용)</del></summary>
<div markdown = 1>

- 피연산자를 비트단위로 논리연산
- 연산 결과
    - | (OR 연산자)
        - 피연산자 중 한 쪽의 값이 1이면 1을 결과로, 그 외는 0
        - 특정 비트의 값을 변경할 떄 주로 사용
            ```
            // 마지막 4bit를 0xF로 변환
                10101011
            OR  00001111
            --------------
                10101111
            ```
    - & (AND 연산자)
        - 피연산자 양쪽의 값이 1이면 1을 결과로, 그 외는 0
        - 주로 특정 비트의 값을 뽑아낼 때 사용
            ```
            // 마지막 4bit를 뽑아내기
                10101011
            AND 00001111
            --------------
                00001011
                ```
    - ^ (XOR 연산자)
        - 피연산자의 값이 다르면 1, 그 외는 0
        - 같은 값으로 XOR연산을 두 번 하면 원래의 값으로 돌아오는 특징
            ```
            // 간단한 암호화
                10101011
            XOR 00001111
            --------------
                10100100

                10100100
            XOR 00001111
            --------------
                10101011 // 원래의 값으로 돌아옴
            ```
</details>

<details>
<summary>비트 전환 연산자<del>(연산 결과, 산술 변환, 별명, 활용)</del></summary>
<div markdown = 1>

- 연산 결과
    - 피연산자를 2진수로 표현했을 때, 0은 1로, 1은 0으로 바꿈
- 산술 변환
    - 단항 연산이지만 피연산자의 타입이 int보다 작으면 int로 산술 변환 후 연산
- a.k.a. '1의 보수' 연산자
- 활용
    - 양의 정수 p에대한 음의 정수 -p를 얻으려면
        - ~p +1
    - 음의 정수 p에대한 양의 정수 p를 얻으려면
        - ~(p-1) (같지만.. 가독성을 위해)
</details>

<details>
<summary>쉬프트 연산자<del>(연산 결과, 연산 과정, 우측 피연산자의 특징, 산술 변환, 결과의 패턴, 자리수, 장점)</del></summary>
<div markdown = 1>

- 연산결과
    - 피연산자의 각 자리(2진수로 표현 시) 오른쪽(>>) 또는 왼쪽(<<)으로 이동
- 연산 과정
    1. 좌측 피연산자 수 만큼 자리 이동
    2. 자리이동으로 저장범위를 벗어난 값들은 버려지고 빈자리는 0(양수) 또는 1(음수)로 채워짐
- 우측 피연산자
    - 정수만 가능
    - 음수일 경우 부호없는 정수로 자동 형변환
- 산술 변환
    - 좌측 피연산자는 int산술변환이 일어남(int보다 작을 때)
    - 우측 피연산자는 타입을 일치시킬 필요가 없기 때문에 산술 변환 x
- 결과의 패턴
    - x << n 은 x * 2<sup>n</sup>의 결과와 동일
    - x >> n 은 x / 2<sup>n</sup>의 결과와 동일
- 자료형의 자리수보다 우측 피연산자의 수가 더 크면
    - 피연산자의 수로 자리수를 나눈 나머지의 수만큼 이동
- 나누기보다 속도가 더 빠름
</details>

## 그 외 연산자

<details>
<summary>조건 연산자<del>(연산 결과, 산술 변환, 중첩문)</del></summary>
<div markdown = 1>

- 삼항 연산자
    ```
    조건식 ? 식1 : 식2
    ```
- 연산 결과
    - 조건식의 평가 결과가 true이면 식1을, false이면 식2
- 중첩문 사용 가능
    ```
    int result = x > 0 ? 1 : ( x == 0 ? 0 : -1);
    ```
- 산술 변환
    - 조건 연산자의 식1, 식2의 타입이 다른 경우 산술변환 발생
</details>

<details>
<summary>대입 연산자<del>(정의, 연산 과정, 연산 결과, 우선순위, 진행방향, lvalue, 복합)</del></summary>
<div markdown = 1>

- =
- 정의
    - 저장공간에 값 또는 수식의 연산 결과를 저장하는데 사용
- 연산 과정
    - 오른쪽 피연산자의 값(or 평가 값)을 왼쪽 피연산자에 저장
- 연산 결과
    - 저장된 값을 연산 결과로 반환
- 우선순위
    - 연산자들 중 가장 낮은 우선순위
- 진행 방향
    - 오른쪽 ➝ 왼쪽
- lvalue
    - lvalue(left), rvalue(right)
    - lvalue는 반드시 변수처럼 변경 가능해야
        - 리터럴, 상수 안됨
- 복합 대입 연산자
    - 다른 연산자와의 결합
    - 타 연산자와 대입 연산자 간에 공백이 없어야
    - 예시
    ```
    int a += 3 // int a = a + 3;과 동일
    ```
</details>

## 참고
- 남궁성의 자바의 정석 3장