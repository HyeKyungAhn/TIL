# The Linux Command Line(5th)

## part 1 - Learning the Shell

- Shell이란, 키보드로 입력한 명령어를 OS로 전달해 실행할 수 있게하는 프로그램이다.
- 운영체제의 가장 바깥 부분을 둘러싸고 있다는 의미로 Shell이라는 이름을 가짐
- shell prompt
  ```
  [username@machinename ~]$
  ```
  - $ 대신 #이 표시된다면 root 권한으로 terminal session을 사용한다는 의미

## part 2 - Navigation

파일 시스템을 누비기 위해서는 세 가지 명령어를 알아야한다(pwd, ls, cd)

- File System Tree 이해하기
  - 윈도우나 다른 유닉스 계열의 OS 처럼 리눅스도 계층적 디렉터리 시스템
  - 다른 OS와 차이점은 **오직 하나의 파일 시스템만** 가지고 있다는 것
    - 외부 저장 장치들은 (수와 관련 없이) Linux File System Tree에 마운트(mounted), 즉 덭붙여진다.
    - 어디 붙여지냐는 관련 책임자의 재량에 달림
- pwd: 현재 위치한(작업 중인) 디렉터리의 절대 경로를 출력
- ls: 현재 작업 중인 디렉터리 내의 파일과 디렉터리 목록을 보여준다
- cd: 현재 작업 중인 디렉터리를 옮길 때 사용
- 파일 이름에 관한 중요한 사실
  1. 점(.)으로 시작하는 파일 이름은 숨겨진다. ls -a로 목록을 검색하지 않는 이상.
  2. case sensitive하다
  3. linux에는 확장자라는 개념이 없다. 파일의 용도와 내용을 결정할 때 다른 방식을 사용.
  4. 리눅스는 공백이나 구두점 문자를 파일이름으로 지원하지만, 생성하는 파일의 이름에는 공백을 허용하지 않고 구두점도 세 개('.', '-', '\_')만 허용한다.

## part 3 - Exploring the System

이번 장에서는 시스템을 돌아다니며 그 중 읽을 수 있는 text 파일을 살펴본다. 시스템을 돌아다니며 구경하기 위해 ls(와 여러 옵션들), file, less 명령어가 도움이 된다.

- ls -l로 긴 형식의 파일 정보의 속성들을 들여다볼 수 있다.

  ```
  -rw-r--r-- 1 root root 1186219 2017-04-03 11:05 kubuntu-leaflet.png
  -rw-r--r-- 1 root root 47584 2017-04-03 11:05 logo-Edubuntu.png
  ```

  맨 첫번째 줄의 파일 정보의 속성을 보면 여러 정보를 알 수 있다.

  ` -rw-r--r--` : 파일의 타입과 권한을 알 수 있다. 맨 첫번째 문자는 타입(d-directory, l-link)을, 그 다음 세문자는 파일 작성자의 권한을, 그 다음 세문자는 파일 그룹의 권한을, 마지막 세 문자는 그 외의 모든 사람들의 권한을 나타낸다.

  `1` : 파일의 하드 링크 수

  `root` : 파일의 소유자의 유저 이름

  `root` : 파일이 속한 그룹 명

  `1186219` : 파일 크기(byte)

  `2017-04-03 11:05` : 파일 최종 수정 일시

  `kubuntu-leaflet.png` : 파일 명

- file 명령어는 파일 컨텐츠에 대한 짧은 설명을 출력한다. 유닉스 계열의 Linux 같은 OS에서의 통념은 "모든 것이 파일이다"는 것이다. 이 말이 아직은 모호하지만 차차 알아가보자.
- less 명령어로 시스템을 돌아다니면서 ASCII text 파일들을 읽어봤다.
  - text는 단순히 문자와 숫자를 매핑한 것을 포함한다. plain ASCII text와 달리 MS word나 LibreOffice Writer는 파일의 형식이나 구조를 표현하기 위해 non-text 요소를 포함한다.
  - Linux는 여러 중요한 설정 파일들이 text 파일로 작성되어있다. 이는 리눅스 시스템이 사용자에게 열려있으며 많은 것을 공부하고 자세히 살펴볼 수 있도록 작성되었다는 것을 의미하기도 한다.
- Symbolic Link

  - 심볼릭 링크는 자바의 인터페이스와 유사하다. 사용하는 클래스가 변경될 경우 참조되는 모든 곳의 클래스 명을 변경하지 않기 위해 인터페이스로 간접 참조하는 것과 비슷하다.

    버전이 자주 변하는 공유 리소스를 사용하는 모든 곳에서 버전 명(또는 바뀔 떄마다 변하는 이름)을 알 수 있게 파일이름을 작성하되, 버전이 변하더라도 같은 이름으로 참조할 수 있도록 symbolic link를 사용한다. 같은 이름의 파일을 여러 다른 이름으로 참조할 수도 있다. 인터페이스와 다른 점은, 하나의 symbolic link명은 하나의 특정한 공유리소스를 참조함으로 파일 변경시 기존 symbolic link는 삭제하고 동일한 이름으로 symbolic link를 생성해야한다는 것이다.

## part 4 - Manipulating Files and Directories

- cp, mv, mkdir, rm, ln으로 파일과 디렉터리를 생성하고 이동, 복사, 이름 수정을 하고 삭제할 수 있다.
- GUI로도 파일 및 디렉터리를 생성, 수정, 삭제를 할 수 있는데 왜 오래된 CLI로 하는걸까? 강력하고 유연하기 때문이다. 옵션이나 인자를 여러개 줘서 GUI로는 여러번 클릭해야할 작업을 한 번에 할 수 있다.

### Wildcards

와일드 카드는 조건에 맞는 여러개의 파일을 한 번에 지정할 수 있게하는 마법의 문자이다.
|Wildcard|의미|
|----|---------|
|\*|0을 포함한 임의의 수의 문자를 나타냄|
|?|하나의 문자를 표현|
|[ ]|또는(or) 관계를 표현. (예: [abc] 는 '문자 a 또는 b 또는 c'를 표현한다)
|[[:class]]| 지정된 클래스의 멤버와 어느 한 문자가 일치하는지|

### Hard Link

모든 파일은 하나의 하드링크가 있다. 이 하드링크로 파일은 이름을 가질 수 있다. 해당 파일에 대한 추가 하드링크를 생성할 때 파일에 대한 추가적인 입구(entry)를 생성하는 것이다.

그럼 하드링크들은 어떻게 파일을 참조하는 걸까? 파일의 구성은 크개 2부분으로 나뉜다.

1. 파일 내용 부분(inode + file content)
2. 파일 이름 부분(hard link)

하드링크를 생성할 때 2번의 파일의 이름부분을 생성하는 것이다. 생성된 하드링크는 inode를 참조하는데,
inode는 파일의 메타데이터, chain of disk block(파일 내용) 포인터등을 저장하는 데이터 구조다. 하드링크가 참조하는 기존 파일의 inode로 파일의 실제 내용을 관리할 수 있다. 하나의 파일에 대해 여러 개의 하드링크를 생성해도 동일한 inode를 참조하기 때문에 하나의 파일이 여러개의 하드링크, 곧 이름을 가질 수 있다.

#### Hard Link가 같은 파일을 가리키는지 확인하기

하드링크가 같은 파일을 가리키는지 확인하는 방법은 ls 명령어의 -i 옵션을 사용하는 것이다. 맨 왼쪽에 inode 번호가 나오는데, 동일한 번호를 가지고 있다면 같은 파일을 가리키는 것이다.

### Symbolic Link

하드링크에는 한계가 있다.

1. 하드링크는 자체 파일 시스템이 아닌 외부의 물리적 기기를 참조할 수 없다.
2. 하드링크는 파일만 참조할 수 있다.

그래서 심볼릭 링크가 있는 것이다. 심볼릭 링크는 파일 또는 디렉터리에 대한 텍스트 포인터를 포함하고 있는 특수한 종류의 파일이다. part 3에서도 설명했으니 더이상의 설명은 생략하겠다.

#### Symbolic Link 생성 시 주의점

심볼릭 링크를 생성할 때 하나 주의해야할 점이 있다.

```
[user@machin /root/playground]#ln -s ../networks dir1/networks_sym
```

심볼릭 링크를 타겟 파일 또는 디렉터리와 **동일하지 않은** 디렉터리에 생성하는 상황을 가정한다. 상대경로로 심볼릭 링크를 생성할 때 심볼릭 링크가 생성될 위치를 기준으로 타겟이 어디있는지에 대한 text 설명을 생성한다. 따라서 타겟 파일의 상대 경로를 심볼릭 링크의 위치를 기준으로 작성해야한다. 그렇지 않으면 broken link가 된다.

물론 심볼릭 링크를 생성할 때 절대경로를 사용할 수도 있다. 하지만 상대 경로를 책에서는 추천하는데, 그 이유는 디렉터리의 위치를 옮길 때 상대 경로만 유지하면 어디서든 링크를 유지, 사용할 수 있기 때문이다.

### Link의 삭제

대부분의 파일 명령어는 link의 타겟(파일, 디렉터리)를 대상으로 한다. 하지만 rm은 예외다. 링크를 삭제할 때는 링크가 가리키는 실제 파일이 아닌, 링크 그 자체를 삭제한다. 원본은 남아있다.

만약 링크가 있는 상태에서 링크가 가리키는 파일 또는 디렉터리를 먼저 삭제한다면 어떻게 될까? 링크는 여전히 있지만 참조하는 대상이 없기 때문에 broken link가 된다.
